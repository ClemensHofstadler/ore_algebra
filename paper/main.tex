\documentclass{amsart}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage{a4wide}
\usepackage{sagetex}

\parindent=0pt
\parskip\smallskipamount

\let\set\mathbbm
\def\<#1>{\langle#1\rangle}
\let\ideal\unlhd
\def\i{\mathrm{i}}
\def\e{\mathrm{e}}

\def\Bold#1{\mathbf{#1}}

\newtheorem{thm}{Theorem}
\newtheorem{prop}{Proposition}
\newtheorem{defn}{Definition}
\newtheorem{conj}{Conjecture}

\newcommand\todo[1][.]{\edef\tmpa{.}\edef\tmpb{#1}%
  \ifx\tmpa\tmpb
    \typeout{To Be on page \thepage}\fbox{\bf To Be}
  \else
    \typeout{To Be on page \thepage: #1}\fbox{{\bf To Be:} #1}
  \fi
}

\begin{document}

 \author[Manuel Kauers, Maximilian Jaroschek, Fredrik Johansson]
   {Manuel Kauers\,$^\ast$, Maximilian Jaroschek\,$^\ast$, Fredrik Johansson\,$^\ast$}
 \address{Manuel Kauers, Research Institute for Symbolic Computation (RISC), J. Kepler University Linz, Austria}
 \email{mkauers@risc.uni-linz.ac.at}
 \address{Maximilian Jaroschek, Research Institute for Symbolic Computation (RISC), J. Kepler University Linz, Austria}
 \email{mjarosch@risc.uni-linz.ac.at}
 \address{Fredrik Johansson, Research Institute for Symbolic Computation (RISC), J. Kepler University Linz, Austria}
 \email{fjohanss@risc.uni-linz.ac.at}
 \thanks{$^\ast$ Supported by the Austrian FWF grant Y464-N18.}

 \title{Ore Polynomials in Sage}

 \begin{abstract}
We present a Sage implementation of Ore algebras. The main features for the most
common instances include basic arithmetic and actions; gcrd and lclm; D-finite
closure properties; natural transformations between related algebras; guessing;
desingularization; solvers for polynomials, rational functions and (generalized)
power series. This paper is a tutorial on how to use the package.
 \end{abstract}

 \maketitle

%%% page limit: 20, goal: 15--20.

\section{Introduction}

In computer algebra, objects are often described implicitly through equations
they satisfy. For example, the exponential function $\exp(x)$ is uniquely
specified by the linear differential equation $f'(x)-f(x)=0$ and the initial
value $f(0)=1$.  Likewise, the sequence $F_n$ of Fibonacci numbers is uniquely
determined by the linear recurrence $F_{n+2}-F_{n+1}-F_n=0$ and the two initial
values $F_0=0$,~$F_1=1$.  Especially for representing functions or sequences
that cannot be expressed in ``closed form'', the differential or difference
equations they may satisfy provide an attractive way to store them on the
computer. The question is then how to calculate with objects which are given in
this form.

Algorithms for Ore algebras provide a systematic answer to this
question~\cite{..,..}.  Invented in the early 20th century~\cite{..} with the
objective of providing a unified theory for various kinds of linear operators,
they have been used for many years in computer algebra systems, for example in
the Maple packages gfun~\cite{..} and mgfun~\cite{..}, in the Mathematica
packages by Mallinger~\cite{..} and Koutschan~\cite{..,..}, and
elsewhere~\cite{..}. 

The purpose of this paper is to introduce an implementation of a collection of
algorithms related to Ore algebras for the computer algebra system
Sage~\cite{..}. It is addressed to first-time users who are already familiar
with Sage, and with the theory of Ore algebras and their use for doing symbolic
computation for special functions. Readers unfamiliar with Sage are referred
to~\cite{..}, and readers unfamiliar with Ore algebras may wish to consult the
recent tutorial~\cite{..} and the references given there for an introduction to
the subject.

At the time of writing, the package we describe here is still under construction
and has not yet been incorporated into the official Sage distribution. Readers
who want to try it out are invited to download the current development version
from [URL] and are encouraged to send us bug reports and other comments. We hope
that the community will find the code useful.

SHORT DEMO HOW TO INSTALL AND LAUNCH IT (TO BE DETERMINED)

\begin{sageexample}
  sage: load("ore_algebra.py");  #### TO BE FIXED ####
  sage: R.<x> = PolynomialRing(ZZ); A.<Dx> = OreAlgebra(R, 'Dx')
  sage: A
  sage: A.random_element()
  sage: Dx*x
  sage: B.<Sx> = OreAlgebra(R, 'Sx')
  sage: B
  sage: Sx*x
\end{sageexample}

DISCLAIMER: SO FAR WE MAINLY SUPPORT UNIVARIATE OPERATORS.

HOWEVER: FOR THESE WE HAVE MORE OPERATIONS THAT GFUN OR MALLINGER. 

\section{Ore Algebras and Ore Polynomials}

\subsection{In Theory}

basic facts and definitions

reference to literature

\subsection{In Sage}

ground rings 

general sigma and delta

predefined shortcuts: D, T, S, F, J, Q, C

\section{General Methods}

arithmetic, lclm, gcrd, action, coercion and conversion, pretty printing, coefficient extraction,
closure properties, associate solutions. 

\section{Special Methods Standard Algebras}

special methods available for univ algebras with univ algebra as ground ring

\subsection{Differential Operators}

D and theta

\subsection{Recurrence Operators}

delta and S

\subsection{The $q$-Case}

J and Q

\section{Guessing}

\section{Further Examples}

Some longer session showing how to solve a meaningful problem by using several features of the code. Ideas?

\subsection{}

\subsection{}

 \bibliographystyle{plain}
 \bibliography{main}
 
\end{document}
